#!/usr/bin/env python3
"""
Advanced Penetration Testing Suite for ConnectlyIPT
Professional-grade security testing beyond basic vulnerability scanning
"""

import requests
import json
import time
import sys
import base64
import hashlib
import random
import string
from datetime import datetime
from urllib.parse import urlencode, quote

BASE_URL = "http://127.0.0.1:8000"

class AdvancedPenetrationTester:
    def __init__(self):
        self.results = []
        self.session = requests.Session()
        self.csrf_token = None
        
    def log_test(self, category, test_name, result, details="", risk_level="INFO"):
        """Log penetration test results"""
        entry = {
            "category": category,
            "test": test_name,
            "result": result,
            "risk_level": risk_level,
            "details": details,
            "timestamp": datetime.now().isoformat()
        }
        self.results.append(entry)
        
        risk_emoji = {"LOW": "[LOW]", "MEDIUM": "[MED]", "HIGH": "[HIGH]", "CRITICAL": "[CRIT]", "INFO": "[INFO]"}
        print(f"{risk_emoji.get(risk_level, '[INFO]')} [{category}] {test_name}: {result}")
        if details:
            print(f"    Details: {details}")
    
    def get_csrf_token(self):
        """Extract CSRF token for authenticated requests"""
        try:
            response = self.session.get(f"{BASE_URL}/admin/login/")
            if 'csrftoken' in response.cookies:
                self.csrf_token = response.cookies['csrftoken']
                return True
        except:
            pass
        return False
    
    # ===== AUTHENTICATION TESTING =====
    
    def test_authentication_bypass(self):
        """Test various authentication bypass techniques"""
        print("\n=== AUTHENTICATION BYPASS TESTING ===")
        
        # Test 1: SQL Injection in login
        payloads = [
            "' OR '1'='1' --",
            "admin' --",
            "' OR 1=1 #",
            "' UNION SELECT 1,2,3 --"
        ]
        
        for payload in payloads:
            try:
                data = {
                    'username': payload,
                    'password': 'test'
                }
                response = self.session.post(f"{BASE_URL}/api/auth/token/", 
                                           json=data, timeout=5)
                
                if response.status_code == 200 and 'token' in response.text:
                    self.log_test("AUTH_BYPASS", f"SQL Injection Login: {payload}", 
                                "VULNERABLE", "Authentication bypass successful!", "CRITICAL")
                else:
                    self.log_test("AUTH_BYPASS", f"SQL Injection Login: {payload}", 
                                "SECURE", "Payload rejected", "INFO")
            except:
                self.log_test("AUTH_BYPASS", f"SQL Injection Login: {payload}", 
                            "SECURE", "Payload caused error (good)", "INFO")
        
        # Test 2: JWT Token Manipulation
        fake_jwt = "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VyX2lkIjoxLCJ1c2VybmFtZSI6ImFkbWluIiwiZXhwIjoxNjk5OTk5OTk5fQ.fake_signature"
        
        headers = {'Authorization': f'Token {fake_jwt}'}
        try:
            response = self.session.get(f"{BASE_URL}/api/posts/", headers=headers, timeout=5)
            if response.status_code == 200:
                self.log_test("AUTH_BYPASS", "Fake JWT Token", "VULNERABLE", 
                            "Fake JWT accepted", "CRITICAL")
            else:
                self.log_test("AUTH_BYPASS", "Fake JWT Token", "SECURE", 
                            "Fake JWT rejected", "INFO")
        except:
            self.log_test("AUTH_BYPASS", "Fake JWT Token", "SECURE", 
                        "Token validation working", "INFO")
    
    def test_session_management(self):
        """Test session management vulnerabilities"""
        print("\n=== SESSION MANAGEMENT TESTING ===")
        
        # Test 1: Session Fixation
        self.log_test("SESSION", "Session Fixation", "MANUAL_CHECK", 
                     "Check if session ID changes after login", "MEDIUM")
        
        # Test 2: Session Timeout
        self.log_test("SESSION", "Session Timeout", "MANUAL_CHECK", 
                     "Verify sessions expire appropriately", "LOW")
    
    # ===== INJECTION TESTING =====
    
    def test_sql_injection(self):
        """Test for SQL injection vulnerabilities"""
        print("\n=== SQL INJECTION TESTING ===")
        
        # Test endpoints that might be vulnerable
        endpoints = [
            "/api/posts/",
            "/api/auth/",
            "/admin/"
        ]
        
        sql_payloads = [
            "1' OR '1'='1",
            "1; DROP TABLE users; --",
            "1' UNION SELECT * FROM users --",
            "1' AND (SELECT COUNT(*) FROM users) > 0 --"
        ]
        
        for endpoint in endpoints:
            for payload in sql_payloads:
                try:
                    # Test in URL parameters
                    response = self.session.get(f"{BASE_URL}{endpoint}?id={quote(payload)}", timeout=5)
                    
                    # Look for SQL error messages
                    sql_errors = [
                        "sql syntax",
                        "mysql",
                        "postgresql",
                        "sqlite",
                        "syntax error",
                        "database error"
                    ]
                    
                    response_lower = response.text.lower()
                    if any(error in response_lower for error in sql_errors):
                        self.log_test("SQL_INJECTION", f"{endpoint} - {payload[:20]}...", 
                                    "POTENTIAL", "SQL error detected", "HIGH")
                    else:
                        self.log_test("SQL_INJECTION", f"{endpoint} - {payload[:20]}...", 
                                    "SECURE", "No SQL errors", "INFO")
                except:
                    self.log_test("SQL_INJECTION", f"{endpoint} - {payload[:20]}...", 
                                "SECURE", "Request failed safely", "INFO")
    
    def test_xss_injection(self):
        """Test for Cross-Site Scripting vulnerabilities"""
        print("\n=== XSS INJECTION TESTING ===")
        
        xss_payloads = [
            "<script>alert('XSS')</script>",
            "<img src=x onerror=alert('XSS')>",
            "<svg onload=alert('XSS')>",
            "javascript:alert('XSS')",
            "'><script>alert('XSS')</script>",
            "\"><script>alert('XSS')</script>"
        ]
        
        # Test in different contexts
        test_contexts = [
            ("URL Parameter", lambda p: f"{BASE_URL}/api/posts/?search={quote(p)}"),
            ("User Agent", lambda p: {"User-Agent": p}),
            ("Referer", lambda p: {"Referer": p})
        ]
        
        for context_name, context_func in test_contexts:
            for payload in xss_payloads:
                try:
                    if context_name == "URL Parameter":
                        response = self.session.get(context_func(payload), timeout=5)
                    else:
                        headers = context_func(payload)
                        response = self.session.get(f"{BASE_URL}/", headers=headers, timeout=5)
                    
                    # Check if payload is reflected without encoding
                    if payload.replace("<", "&lt;").replace(">", "&gt;") not in response.text and payload in response.text:
                        self.log_test("XSS", f"{context_name} - {payload[:20]}...", 
                                    "POTENTIAL", "Unencoded payload reflected", "MEDIUM")
                    else:
                        self.log_test("XSS", f"{context_name} - {payload[:20]}...", 
                                    "SECURE", "Payload properly encoded/filtered", "INFO")
                except:
                    self.log_test("XSS", f"{context_name} - {payload[:20]}...", 
                                "SECURE", "Request failed safely", "INFO")
    
    # ===== AUTHORIZATION TESTING =====
    
    def test_broken_access_control(self):
        """Test for broken access control vulnerabilities"""
        print("\n=== ACCESS CONTROL TESTING ===")
        
        # Test 1: Direct object references
        test_urls = [
            "/api/posts/1/",
            "/api/posts/999/",
            "/admin/auth/user/1/",
            "/admin/auth/user/999/"
        ]
        
        for url in test_urls:
            try:
                response = self.session.get(f"{BASE_URL}{url}", timeout=5)
                
                if response.status_code == 200:
                    self.log_test("ACCESS_CONTROL", f"Direct Access: {url}", 
                                "POTENTIAL", "Object accessible without auth", "MEDIUM")
                elif response.status_code == 401:
                    self.log_test("ACCESS_CONTROL", f"Direct Access: {url}", 
                                "SECURE", "Authentication required", "INFO")
                elif response.status_code == 403:
                    self.log_test("ACCESS_CONTROL", f"Direct Access: {url}", 
                                "SECURE", "Authorization required", "INFO")
                else:
                    self.log_test("ACCESS_CONTROL", f"Direct Access: {url}", 
                                "INFO", f"Status: {response.status_code}", "INFO")
            except:
                self.log_test("ACCESS_CONTROL", f"Direct Access: {url}", 
                            "SECURE", "Request failed", "INFO")
    
    def test_privilege_escalation(self):
        """Test for privilege escalation vulnerabilities"""
        print("\n=== PRIVILEGE ESCALATION TESTING ===")
        
        # Test 1: Parameter pollution
        admin_params = [
            "is_admin=true",
            "role=admin",
            "privilege=1",
            "is_staff=true",
            "permission=admin"
        ]
        
        for param in admin_params:
            try:
                response = self.session.get(f"{BASE_URL}/api/posts/?{param}", timeout=5)
                self.log_test("PRIVILEGE_ESC", f"Parameter Pollution: {param}", 
                            "TESTED", "Manual verification needed", "LOW")
            except:
                pass
    
    # ===== BUSINESS LOGIC TESTING =====
    
    def test_business_logic_flaws(self):
        """Test for business logic vulnerabilities"""
        print("\n=== BUSINESS LOGIC TESTING ===")
        
        # Test 1: Negative values
        test_data = [
            {"amount": -100, "test": "Negative values"},
            {"quantity": 0, "test": "Zero values"},
            {"price": 999999999, "test": "Large values"},
            {"id": -1, "test": "Negative ID"}
        ]
        
        for data in test_data:
            try:
                response = self.session.post(f"{BASE_URL}/api/posts/", 
                                           json=data, timeout=5)
                self.log_test("BUSINESS_LOGIC", data["test"], "TESTED", 
                            f"Response: {response.status_code}", "LOW")
            except:
                self.log_test("BUSINESS_LOGIC", data["test"], "SECURE", 
                            "Request validation working", "INFO")
    
    # ===== INFORMATION DISCLOSURE TESTING =====
    
    def test_information_disclosure(self):
        """Test for information disclosure vulnerabilities"""
        print("\n=== INFORMATION DISCLOSURE TESTING ===")
        
        # Test 1: Error pages
        error_urls = [
            "/nonexistent",
            "/api/nonexistent",
            "/admin/nonexistent",
            "/../../../etc/passwd",
            "/admin/../../../etc/passwd"
        ]
        
        for url in error_urls:
            try:
                response = self.session.get(f"{BASE_URL}{url}", timeout=5)
                
                # Check for sensitive information
                sensitive_info = [
                    "traceback",
                    "secret_key",
                    "database",
                    "debug",
                    "/home/",
                    "/var/",
                    "django.conf"
                ]
                
                response_lower = response.text.lower()
                found_info = [info for info in sensitive_info if info in response_lower]
                
                if found_info:
                    self.log_test("INFO_DISCLOSURE", f"Error Page: {url}", 
                                "VULNERABLE", f"Sensitive info: {found_info}", "HIGH")
                else:
                    self.log_test("INFO_DISCLOSURE", f"Error Page: {url}", 
                                "SECURE", "No sensitive information", "INFO")
            except:
                self.log_test("INFO_DISCLOSURE", f"Error Page: {url}", 
                            "SECURE", "Request failed safely", "INFO")
    
    def run_full_pentest(self):
        """Run the complete penetration testing suite"""
        print("Advanced Penetration Testing Suite")
        print("=" * 50)
        print("Testing comprehensive attack vectors...")
        
        # Run all tests
        self.test_authentication_bypass()
        self.test_session_management()
        self.test_sql_injection()
        self.test_xss_injection()
        self.test_broken_access_control()
        self.test_privilege_escalation()
        self.test_business_logic_flaws()
        self.test_information_disclosure()
        
        # Generate summary
        print("\n" + "=" * 50)
        print("PENETRATION TESTING SUMMARY")
        print("=" * 50)
        
        risk_counts = {"CRITICAL": 0, "HIGH": 0, "MEDIUM": 0, "LOW": 0, "INFO": 0}
        for result in self.results:
            risk_counts[result["risk_level"]] += 1
        
        print(f"Total Tests: {len(self.results)}")
        print(f"Critical: {risk_counts['CRITICAL']}")
        print(f"High: {risk_counts['HIGH']}")
        print(f"Medium: {risk_counts['MEDIUM']}")
        print(f"Low: {risk_counts['LOW']}")
        print(f"Info: {risk_counts['INFO']}")
        
        # Save detailed report
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        report_file = f"advanced_pentest_report_{timestamp}.json"
        
        with open(report_file, 'w') as f:
            json.dump(self.results, f, indent=2)
        
        print(f"\nDetailed report saved to: {report_file}")
        return self.results

def main():
    tester = AdvancedPenetrationTester()
    results = tester.run_full_pentest()

if __name__ == "__main__":
    main()